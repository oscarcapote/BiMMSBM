

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>__init__ &mdash; MMSBM_library 04/06/2025 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=27c3e253"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MMSBM_library
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MMSBM_library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">__init__</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for __init__</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>


<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">MMSBM_library.functions</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>

<span class="c1"># import MMSBM_library.functions.utils</span>


<div class="viewcode-block" id="metadata_layer">
<a class="viewcode-back" href="../modules.html#__init__.metadata_layer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">metadata_layer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Principal class of nodes_layer metadata. It contains extra information about the nodes.</span>

<span class="sd">    It has two subclasses:</span>
<span class="sd">        - exclusive_metadata</span>
<span class="sd">        - inclusive_metadata</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lambda_val : float</span>
<span class="sd">        A parameter representing a lambda value.</span>
<span class="sd">    meta_name : str</span>
<span class="sd">        Name of the metadata.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    N_att : int</span>
<span class="sd">        Number of different categorical attributes of the metadata.</span>
<span class="sd">    dict_codes : dict</span>
<span class="sd">        A dictionary to store codes related to the metadata.</span>
<span class="sd">        Codes are integers ranged from 0 to N_att-1.</span>
<span class="sd">    links : 2D NumPy array</span>
<span class="sd">        Array representing links between nodes and metadata using its codes.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __len__()</span>
<span class="sd">        Returns the number of different categorical attributes.</span>
<span class="sd">    __str__()</span>
<span class="sd">        Returns the name of the metadata.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class provides a structure to manage metadata associated with nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="metadata_layer.__init__">
<a class="viewcode-back" href="../modules.html#__init__.metadata_layer.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lambda_val</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the MetadataLayer instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lambda_val : float</span>
<span class="sd">            Parameter that represent the importance of the metadata when the model is inferred.</span>
<span class="sd">        meta_name : str</span>
<span class="sd">            Name of the metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_name</span> <span class="o">=</span> <span class="n">meta_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_val</span> <span class="o">=</span> <span class="n">lambda_val</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dict_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary property to store codes related to the metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing codes related to the metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span>

    <span class="nd">@dict_codes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dict_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span> <span class="o">=</span> <span class="n">dc</span>
        <span class="k">return</span> <span class="n">dc</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">N_att</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of different categorical attributes of the metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Number of different categorical attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N_att</span>

    <span class="nd">@N_att</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">N_att</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N_att</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of different categorical attributes of the metadata</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        N_att : Int</span>
<span class="sd">            Number of different categorical attributes of the metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N_att</span> <span class="o">=</span> <span class="n">N_att</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_att</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Array representing links between nodes and metadata using its codes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            2D array containing the links between nodes and metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_links</span>

    <span class="nd">@links</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">links</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the links property.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        links : np.array</span>
<span class="sd">            2D array containing the links between nodes and metadata</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_links</span> <span class="o">=</span> <span class="n">links</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_links</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>

<div class="viewcode-block" id="metadata_layer.__len__">
<a class="viewcode-back" href="../modules.html#__init__.metadata_layer.__len__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of different categorical attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Number of different categorical attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_att</span></div>


<div class="viewcode-block" id="metadata_layer.__str__">
<a class="viewcode-back" href="../modules.html#__init__.metadata_layer.__str__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of the metadata.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Name of the metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_name</span></div>
</div>




<div class="viewcode-block" id="exclusive_metadata">
<a class="viewcode-back" href="../modules.html#__init__.exclusive_metadata">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">exclusive_metadata</span><span class="p">(</span><span class="n">metadata_layer</span><span class="p">):</span>

<div class="viewcode-block" id="exclusive_metadata.__init__">
<a class="viewcode-back" href="../modules.html#__init__.exclusive_metadata.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lambda_val</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization of the exclusive_metadata class</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lambda_val: float</span>
<span class="sd">            Metadata visibility</span>
<span class="sd">        meta_name: str</span>
<span class="sd">            Name of the metadata column in the node_layer class</span>
<span class="sd">        K: int</span>
<span class="sd">            Number of membership groups of this metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">lambda_val</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">qka</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Probability matrix between groups and attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            Matrix of probabilities between groups and attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qka</span>

    <span class="nd">@qka</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">qka</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qka</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter for the qka property.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        qka : np.array</span>
<span class="sd">            Matrix of probabilities between groups and attributes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qka</span> <span class="o">=</span> <span class="n">qka</span></div>



<div class="viewcode-block" id="inclusive_metadata">
<a class="viewcode-back" href="../modules.html#__init__.inclusive_metadata">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">inclusive_metadata</span><span class="p">(</span><span class="n">metadata_layer</span><span class="p">):</span>

<div class="viewcode-block" id="inclusive_metadata.__init__">
<a class="viewcode-back" href="../modules.html#__init__.inclusive_metadata.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lambda_val</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">,</span> <span class="n">Tau</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization of the inclusive_metadata class</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lambda_val: float</span>
<span class="sd">            Metadata visibility</span>
<span class="sd">        meta_name: str</span>
<span class="sd">            Name of the metadata column in the node_layer class</span>
<span class="sd">        Tau: int</span>
<span class="sd">            Number of membership groups of this metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">lambda_val</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tau</span> <span class="o">=</span> <span class="n">Tau</span></div>



    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_k_tau</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Probability matrix between groups, membership groups and attributes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>
<span class="sd">            Matrix of probabilities between groups, membership groups and attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_q_k_tau</span>

    <span class="nd">@q_k_tau</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q_k_tau</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_k_tau</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setter of the q_k_tau matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_q_k_tau</span> <span class="o">=</span>  <span class="n">q_k_tau</span>


<div class="viewcode-block" id="inclusive_metadata.init_q_k_tau">
<a class="viewcode-back" href="../modules.html#__init__.inclusive_metadata.init_q_k_tau">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_q_k_tau</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">Tau</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization of the q_k_tau matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">K</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value of K must be positive!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Tau</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value of Tau must be positive!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_q_k_tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_att</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_q_k_tau</span></div>
</div>



<div class="viewcode-block" id="nodes_layer">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">nodes_layer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class of a layer that contains nodes</span>

<span class="sd">    Is initialized using a dataframe and can be modify it  using the df attribute</span>

<span class="sd">    The rest of the columns of the dataframe can contain information (metadata) from the nodes.</span>
<span class="sd">    This metadata can be added as a metadata_layer object considering the network as multipartite network.</span>
<span class="sd">    This metadata can be classified it as exclusive_metadata (if a node only accepts one attribute) and inclusive_metadata (if the node accepts more than one attribute)</span>

<span class="sd">    See for more information of metadata: metadata_layer, exclusive_metadata and inclusive_metadata.</span>

<span class="sd">    These objects can be added into a BiNet (bipartite network) where connections between nodes_layer are considered to infer links and their labels  (see BiNet)</span>

<span class="sd">    ...</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    K : int</span>
<span class="sd">        Number of memberships groups for the layer.</span>

<span class="sd">    node_type : str</span>
<span class="sd">        Name of the layer. It corresponds with the column where the nodes&#39; name are contained.</span>

<span class="sd">    df : pandas DataFrame</span>
<span class="sd">        DataFrame that contains information of the nodes. It contains one column</span>
<span class="sd">        with the nodes&#39; name and the rest are its metadata.</span>

<span class="sd">    dict_codes : dict</span>
<span class="sd">        Dictionary with the integer id of the nodes. The key is the nodes&#39; name and the value its id.</span>
<span class="sd">    meta_exclusives : list of metadata_layer</span>
<span class="sd">        List with the metadata exclusives objects that contains the metadata that will be used in the inference.</span>
<span class="sd">    meta_inclusives : list of metadata_layer</span>
<span class="sd">        List with the metadata inclusives object that contains the metadata that will be used in the inference.</span>
<span class="sd">    meta_neighbours_exclusives :</span>
<span class="sd">        Dictionaries of lists that contains, for each node its exclusives metadata neighbours.</span>
<span class="sd">    meta_neighbours_inclusives :</span>
<span class="sd">        Dictionaries of lists that contains, for each node its inclusives metadata neighbours.</span>
<span class="sd">    nodes_observed_inclusive :</span>
<span class="sd">        List of arrays for each metadata with the nodes that has assigned an attribute of the metadata</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="nodes_layer.__init__">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">nodes_name</span><span class="p">,</span> <span class="n">nodes_info</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization of the nodes_layer class</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        K : int</span>
<span class="sd">            Number of memberships groups for the layer.</span>
<span class="sd">        nodes_name : str</span>
<span class="sd">            Name of the nodes column in the nodes_layer class</span>
<span class="sd">        nodes_info : str or pandas DataFrame</span>
<span class="sd">            If it is a string, it is the directory of the file with the nodes information.</span>
<span class="sd">            If it is a DataFrame, it is the DataFrame with the nodes information.</span>
<span class="sd">        separator : str, default \t</span>
<span class="sd">            Separator if the columns of the file that contains the nodes information</span>
<span class="sd">        dict_codes : dict, default None</span>
<span class="sd">            Dictionary with the integer id of the nodes. The key is the nodes&#39; name and the value its id.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">K</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">nodes_name</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">nodes_info</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">nodes_info</span><span class="p">,</span> <span class="n">separator</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">nodes_info</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">nodes_info</span>


        <span class="k">if</span> <span class="n">dict_codes</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int16&quot;</span><span class="p">):</span>
                <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="p">:</span>
                    <span class="n">new_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">new_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="p">:</span>
                    <span class="n">dict_codes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span> <span class="o">=</span> <span class="n">dict_codes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="n">nodes_name</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span><span class="n">dict_codes</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span> <span class="o">=</span> <span class="n">add_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_name</span><span class="p">)</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">nodes_name</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">meta_exclusives</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_inclusives</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_neighbours_exclusives</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_neighbours_inclusives</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># all neighbours (connected and not) of inclusive metadata</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_observed_inclusive</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_observed_exclusive</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_metas</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#Boolean that tells you if you have metadata initialized with non 0 values of lambda_val</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_meta_exclusive</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_meta_inclusive</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_meta</span> <span class="o">=</span> <span class="mi">0</span></div>



    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dict_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span>

    <span class="nd">@dict_codes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dict_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span> <span class="o">=</span> <span class="n">dc</span>
        <span class="k">return</span> <span class="n">dc</span>

<div class="viewcode-block" id="nodes_layer.__getitem__">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.__getitem__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the metadata object with the name metadata_name</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metadata_name : str</span>
<span class="sd">            Name of the metadata</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        metadata_layer</span>
<span class="sd">            metadata_layer object with the name metadata_name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metadata_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="p">[</span><span class="n">metadata_name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">metadata_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="p">[</span><span class="n">metadata_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metadata </span><span class="si">{</span><span class="n">metadata_name</span><span class="si">}</span><span class="s2"> name not found&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="nodes_layer.__setitem__">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.__setitem__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata_name</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the metadata object with the name metadata_name</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metadata_name : str</span>
<span class="sd">            Name of the metadata</span>

<span class="sd">        metadata : metadata_layer</span>
<span class="sd">            metadata_layer object with the name metadata_name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">exclusive_metadata</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="p">[</span><span class="n">metadata_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">metadata</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">inclusive_metadata</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="p">[</span><span class="n">metadata_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">metadata</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metadata </span><span class="si">{</span><span class="n">metadata_name</span><span class="si">}</span><span class="s2"> is not a metadata_layer object&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="nodes_layer.__delitem__">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.__delitem__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes the metadata object with the name metadata_name</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metadata_name : str</span>
<span class="sd">            Name of the metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metadata_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="p">[</span><span class="n">metadata_name</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N_meta_exclusive</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N_meta</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">metadata_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="p">[</span><span class="n">metadata_name</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N_meta_inclusive</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N_meta</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metadata </span><span class="si">{</span><span class="n">metadata_name</span><span class="si">}</span><span class="s2"> name not found&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="nodes_layer.read_file">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.read_file">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the nodes information from a file and returns it as a pandas DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            The filename or path to the file containing nodes information.</span>

<span class="sd">        separator : str, default: &quot;\t&quot;</span>
<span class="sd">            Separator of the nodes DataFrame. Default is &quot;\t&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            A pandas DataFrame containing nodes information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">separator</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;python&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="nodes_layer.create_simple_layer">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.create_simple_layer">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_simple_layer</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">nodes_list</span><span class="p">,</span> <span class="n">nodes_name</span><span class="p">,</span> <span class="n">dict_codes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a nodes_layer object from a list or DataSeries only with the known nodes and without metadata</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        K: Int</span>
<span class="sd">            Number of membership groups of nodes_layer</span>
<span class="sd">        nodes_list: array-like, DataFrame or DataSeries</span>
<span class="sd">            array-like, DataFrame or DataSeries with all the nodes</span>
<span class="sd">        nodes_name: str</span>
<span class="sd">            Name of the nodes type (users, movies, metabolites...) that are or will be in DataFrame</span>
<span class="sd">        dict_codes: dict, None, default: None</span>
<span class="sd">            Dictionary where the keys are the names of nodes, and the values are their ids. If None, the program will generate the ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">new_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">nodes_name</span><span class="p">:</span> <span class="n">nodes_list</span><span class="p">})</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_list</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="n">new_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">nodes_list</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_list</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">new_df</span> <span class="o">=</span> <span class="n">nodes_list</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">nodes_name</span><span class="p">,</span> <span class="n">new_df</span><span class="p">,</span> <span class="n">dict_codes</span><span class="o">=</span><span class="n">dict_codes</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span>

<div class="viewcode-block" id="nodes_layer.update_N">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.update_N">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_N</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N_nodes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Update the number of nodes and reinitialize the membership matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        N_nodes: Int</span>
<span class="sd">            Number of nodes</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span> <span class="o">=</span> <span class="n">N_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span></div>


<div class="viewcode-block" id="nodes_layer.update_K">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.update_K">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Update the number of membership groups of nodes_layer and reinitialize the membership matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        K: Int</span>
<span class="sd">            Number of membership groups of nodes_layer</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">K</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span>

<div class="viewcode-block" id="nodes_layer.add_exclusive_metadata">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.add_exclusive_metadata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_exclusive_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lambda_val</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="n">dict_codes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add exclusive_metadata object to node_layer object</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        meta_name: str</span>
<span class="sd">            Name of the metadata that should be in the node dataframe</span>

<span class="sd">        lambda_val: Float</span>
<span class="sd">            Value of the metadata visibility</span>

<span class="sd">        dict_codes: dict, None, default: None</span>
<span class="sd">            Dictionary where the keys are the names of metadata&#39;s type, and the values are the ids. If None, the program will generate the ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>


        <span class="k">if</span> <span class="n">lambda_val</span><span class="o">&gt;</span><span class="mf">1.e-16</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_metas</span> <span class="o">=</span> <span class="kc">True</span>



        <span class="c1"># create metadata object</span>
        <span class="n">em</span> <span class="o">=</span> <span class="n">exclusive_metadata</span><span class="p">(</span><span class="n">lambda_val</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">)</span>


        <span class="c1"># print(self.df.columns,df_dropna.columns)</span>

        <span class="k">if</span> <span class="n">dict_codes</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">df_dropna</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">meta_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">df_dropna</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">meta_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">df_dropna</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">meta_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int16&quot;</span><span class="p">):</span>
                <span class="n">dict_codes</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="n">em</span><span class="o">.</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes</span>
            <span class="n">df_dropna</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="n">meta_name</span> <span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span><span class="n">dict_codes</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">em</span><span class="o">.</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">add_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">)</span>

        <span class="n">df_dropna</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">meta_name</span><span class="p">])</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="n">df_dropna</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">em</span><span class="o">.</span><span class="n">_meta_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_meta_exclusive</span>

        <span class="n">em</span><span class="o">.</span><span class="n">links</span> <span class="o">=</span> <span class="n">df_dropna</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">,</span> <span class="n">meta_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">em</span><span class="o">.</span><span class="n">N_att</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">)</span>

        <span class="c1">#list of arrays of ints where the array number att has all the index positions of links that connects the attribute att</span>
        <span class="n">em</span><span class="o">.</span><span class="n">masks_att_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">N_att</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">r</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">em</span><span class="o">.</span><span class="n">masks_att_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>


        <span class="c1"># update meta related nodes attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="p">[</span><span class="n">meta_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">em</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_observed_exclusive</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">em</span><span class="p">)]</span> <span class="o">=</span> <span class="n">observed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_meta_exclusive</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_meta</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">meta_neighbours</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">observed</span><span class="p">:</span>
            <span class="n">meta_neighbours</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span> <span class="p">]</span><span class="o">==</span> <span class="n">n</span><span class="p">][</span><span class="n">meta_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span><span class="c1">#.values</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meta_neighbours_exclusives</span><span class="p">[</span><span class="n">meta_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_neighbours</span>

        <span class="k">return</span> <span class="n">em</span></div>







<div class="viewcode-block" id="nodes_layer.add_inclusive_metadata">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.add_inclusive_metadata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_inclusive_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lambda_val</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">,</span> <span class="n">Tau</span><span class="p">,</span><span class="o">*</span><span class="p">,</span><span class="n">dict_codes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add inclusive_metadata object to node_layer object</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        meta_name: str</span>
<span class="sd">            Name of the metadata that should be in the node dataframe</span>

<span class="sd">        lambda_val: float</span>
<span class="sd">            Value of the metadata visibility</span>

<span class="sd">        Tau: Int</span>
<span class="sd">            Number of membership groups of metadata</span>

<span class="sd">        separator: str, default: &quot;|&quot;</span>
<span class="sd">            Separator that is used to differentiate the different metadata assigned for each node</span>

<span class="sd">        dict_codes: dict, None, default: None Dictionary where the keys are the names of metadata&#39;s type,</span>
<span class="sd">        and the values are the ids. If None, the program will generate the ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># create metadata object</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">inclusive_metadata</span><span class="p">(</span><span class="n">lambda_val</span><span class="p">,</span> <span class="n">meta_name</span><span class="p">,</span> <span class="n">Tau</span><span class="p">)</span>
        <span class="n">im</span><span class="o">.</span><span class="n">_separator</span> <span class="o">=</span> <span class="n">separator</span>
        <span class="n">im</span><span class="o">.</span><span class="n">_meta_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_meta_inclusive</span>
        <span class="c1"># im.q_k_tau(self.K, Tau, 2)lambda_val, meta_name, Tau</span>

        <span class="c1"># links and neighbours</span>
        <span class="n">df_dropna</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">meta_name</span><span class="p">])</span>
        <span class="n">meta_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">meta_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">observed</span> <span class="o">=</span> <span class="n">df_dropna</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Nodes with known metadata</span>
        <span class="n">observed_id</span> <span class="o">=</span> <span class="n">df_dropna</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># Nodes with known metadata</span>


        <span class="k">if</span> <span class="n">lambda_val</span><span class="o">&gt;</span><span class="mf">1.e-16</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_metas</span> <span class="o">=</span> <span class="kc">True</span>


        <span class="c1"># encode metadata</span>
        <span class="n">meta_neighbours</span> <span class="o">=</span> <span class="p">[]</span><span class="c1">#meta connected with 1</span>

        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">observed_id</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">meta_list</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">pd</span><span class="o">.</span><span class="n">NaT</span><span class="p">:</span>
                <span class="n">meta_neighbours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">meta_neighbours</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">separator</span><span class="p">)])</span>


        <span class="k">if</span> <span class="n">dict_codes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">meta_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">meta_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">meta_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int16&quot;</span><span class="p">):</span>
                <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="p">:</span>
                    <span class="n">new_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">new_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="p">:</span>
                    <span class="n">dict_codes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">codes</span> <span class="o">=</span> <span class="n">dict_codes</span>
            <span class="n">im</span><span class="o">.</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">codes</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">meta_neighbours</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">codes</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">codes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">codes</span><span class="p">))</span>
            <span class="n">im</span><span class="o">.</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">codes</span>


        <span class="n">decodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">codes</span><span class="p">}</span>
        <span class="n">im</span><span class="o">.</span><span class="n">decodes</span> <span class="o">=</span> <span class="n">decodes</span>
        <span class="n">im</span><span class="o">.</span><span class="n">N_att</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">codes</span><span class="p">))</span>

        <span class="n">meta_neighbours</span> <span class="o">=</span> <span class="p">[[</span><span class="n">im</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">L</span><span class="p">]</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">meta_neighbours</span><span class="p">]</span>

        <span class="c1"># Links between node and metadata type</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span> <span class="o">*</span> <span class="n">im</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="c1"># Label of the link: 0 if not connected 1 if connected</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span> <span class="o">*</span> <span class="n">im</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">observed_id</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">N_att</span><span class="p">):</span>
                <span class="n">links</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>
                <span class="n">links</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">meta_neighbours</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1">#list where the index is the attribute and the element is an array of the nodes that are connected to the same attribute</span>
        <span class="n">im</span><span class="o">.</span><span class="n">neighbours_meta</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">N_att</span><span class="p">):</span>
            <span class="n">im</span><span class="o">.</span><span class="n">neighbours_meta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="n">links</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">att</span><span class="p">][:,</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">im</span><span class="o">.</span><span class="n">masks_att_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">links</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">att</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="p">))]</span>

        <span class="n">im</span><span class="o">.</span><span class="n">links</span> <span class="o">=</span> <span class="n">links</span>
        <span class="n">im</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="n">im</span><span class="o">.</span><span class="n">N_labels</span> <span class="o">=</span> <span class="mi">2</span><span class="c1">#connected or disconnected</span>
        <span class="c1">#nodes neigbours</span>


        <span class="c1">#masks list to know wich links have label r (that is the index of the list)</span>
        <span class="n">im</span><span class="o">.</span><span class="n">masks_label_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">labels</span><span class="o">==</span><span class="n">r</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">im</span><span class="o">.</span><span class="n">masks_label_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># codes = pd.Categorical(self.df[meta_name]).codes</span>
        <span class="c1"># self.df = self.df.join(pd.DataFrame(codes, columns=[meta_name+&quot;_id&quot;]))</span>
        <span class="c1"># self.inclusive_linked.append([[int(j) for j in i.split(separator)] for i in df_dropna [meta_name+&quot;_id&quot;].values])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_observed_inclusive</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">im</span><span class="p">)]</span> <span class="o">=</span> <span class="n">observed_id</span>

        <span class="c1"># update meta related nodes attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">im</span><span class="p">)]</span> <span class="o">=</span> <span class="n">im</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_meta_inclusive</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_meta</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meta_neighbours_inclusives</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">im</span><span class="p">)]</span> <span class="o">=</span> <span class="n">meta_neighbours</span>

        <span class="k">return</span> <span class="n">im</span></div>



<div class="viewcode-block" id="nodes_layer.update_exclusives_id">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.update_exclusives_id">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_exclusives_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">em</span><span class="p">,</span> <span class="n">dict_codes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Changes the ids (the integer assigned to each metadata attribute) given the dict_codes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>

<span class="sd">        dict_codes: dict</span>
<span class="sd">            Dictionary where the keys are the names of metadata&#39;s type, and the values are the ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">replacer</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="p">:</span>
            <span class="n">replacer</span><span class="p">[</span><span class="n">em</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">att</span><span class="p">]]</span><span class="o">=</span> <span class="n">dict_codes</span><span class="p">[</span><span class="n">att</span><span class="p">]</span>

        <span class="n">em</span><span class="o">.</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="n">em</span><span class="o">.</span><span class="n">meta_name</span> <span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span><span class="n">replacer</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">em</span><span class="o">.</span><span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">meta_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1">#list of arrays of ints where the array number att has all the index positions of links that connects the attribute att</span>
        <span class="n">em</span><span class="o">.</span><span class="n">masks_att_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">N_att</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">r</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">em</span><span class="o">.</span><span class="n">masks_att_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>



        <span class="n">meta_neighbours</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">):</span>
            <span class="n">meta_neighbours</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span> <span class="p">]</span><span class="o">==</span> <span class="n">n</span><span class="p">][</span><span class="n">em</span><span class="o">.</span><span class="n">meta_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span><span class="c1">#.values</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meta_neighbours_exclusives</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">em</span><span class="p">)]</span> <span class="o">=</span> <span class="n">meta_neighbours</span></div>



<div class="viewcode-block" id="nodes_layer.update_inclusives_id">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.update_inclusives_id">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_inclusives_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">dict_codes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Changes the ids (the integer assigned to each metadata attribute) given the dict_codes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>

<span class="sd">        dict_codes: dict Dictionary where the keys are the names of metadata&#39;s type, and the values are the ids.</span>
<span class="sd">                    If None, ids will be generated automatically.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_observed_inclusive</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">im</span><span class="p">)]</span>
        <span class="n">meta_neighbours</span> <span class="o">=</span> <span class="p">[]</span>


        <span class="c1">#Replacer to change the ids</span>
        <span class="n">replacer</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="p">:</span>
            <span class="n">replacer</span><span class="p">[</span><span class="n">im</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">att</span><span class="p">]]</span><span class="o">=</span> <span class="n">dict_codes</span><span class="p">[</span><span class="n">att</span><span class="p">]</span>


        <span class="c1">#New ids into the neigbours list</span>
        <span class="k">for</span> <span class="n">neig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta_neighbours_inclusives</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">im</span><span class="p">)]:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ids</span> <span class="ow">in</span> <span class="n">neig</span><span class="p">:</span>
                <span class="n">N</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replacer</span><span class="p">[</span><span class="n">ids</span><span class="p">])</span>
            <span class="n">meta_neighbours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>



        <span class="c1">#changing codes dicts</span>
        <span class="n">codes</span> <span class="o">=</span> <span class="n">dict_codes</span>
        <span class="n">im</span><span class="o">.</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes</span>


        <span class="n">decodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">codes</span><span class="p">}</span>
        <span class="n">im</span><span class="o">.</span><span class="n">decodes</span> <span class="o">=</span> <span class="n">decodes</span>
        <span class="n">im</span><span class="o">.</span><span class="n">N_att</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">codes</span><span class="p">))</span>

        <span class="c1"># Links between node and metadata type</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span> <span class="o">*</span> <span class="n">im</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="c1"># Label of the link: 0 if not connected 1 if connected</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">observed</span><span class="p">)</span> <span class="o">*</span> <span class="n">im</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">observed_id</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">N_att</span><span class="p">):</span>
                <span class="n">links</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>
                <span class="n">links</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">meta_neighbours</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1">#list where the index is the attribute and the element is an array of the nodes that are connected to the same attribute</span>
        <span class="n">im</span><span class="o">.</span><span class="n">neighbours_meta</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">N_att</span><span class="p">):</span>
            <span class="n">im</span><span class="o">.</span><span class="n">neighbours_meta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="n">links</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">att</span><span class="p">][:,</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">im</span><span class="o">.</span><span class="n">masks_att_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">links</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">att</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="p">))]</span>

        <span class="n">im</span><span class="o">.</span><span class="n">links</span> <span class="o">=</span> <span class="n">links</span>
        <span class="n">im</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="n">im</span><span class="o">.</span><span class="n">N_labels</span> <span class="o">=</span> <span class="mi">2</span><span class="c1">#connected or disconnected</span>
        <span class="c1">#nodes neigbours</span>


        <span class="c1">#masks list to know wich links have label r (that is the index of the list)</span>
        <span class="n">im</span><span class="o">.</span><span class="n">masks_label_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">labels</span><span class="o">==</span><span class="n">r</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">im</span><span class="o">.</span><span class="n">masks_label_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>



        <span class="c1"># update meta related nodes attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meta_neighbours_inclusives</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">im</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">L</span><span class="p">]</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">meta_neighbours</span><span class="p">]</span></div>


<div class="viewcode-block" id="nodes_layer.save_nodes_layer">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.save_nodes_layer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_nodes_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        It saves the nodes_layer object</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        dir: str</span>
<span class="sd">            Directory where the json with the nodes_layer information will be saved</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">functions</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">save_nodes_layer_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="nodes_layer.load_nodes_layer_from_file">
<a class="viewcode-back" href="../modules.html#__init__.nodes_layer.load_nodes_layer_from_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_nodes_layer_from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">json_dir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        It loads the nodes_layer object from a JSON file</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        dir: str</span>
<span class="sd">            Directory where the json with the nodes_layer information is saved</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_dir</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nodes_info</span><span class="o">=</span><span class="n">df</span><span class="p">,</span><span class="o">**</span><span class="n">data</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;metadata_exclusives&quot;</span><span class="p">]:</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">add_exclusive_metadata</span><span class="p">(</span><span class="o">**</span><span class="n">m</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;metadata_inclusives&quot;</span><span class="p">]:</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">add_inclusive_metadata</span><span class="p">(</span><span class="o">**</span><span class="n">m</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">layer</span></div>
</div>




<div class="viewcode-block" id="BiNet">
<a class="viewcode-back" href="../modules.html#__init__.BiNet">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BiNet</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class of a Bipartite Network, where two layers of different types of nodes are connected (users-&gt;items,</span>
<span class="sd">    politicians-&gt;bills, patient-&gt;microbiome...) and these links can be labeled with information of the</span>
<span class="sd">    interaction (ratings, votes...).</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    labels_name: str</span>
<span class="sd">        Name of the labels column</span>
<span class="sd">    N_labels: int</span>
<span class="sd">        Number of different types labels.</span>
<span class="sd">    labels_array: ndarray</span>
<span class="sd">        Array with all the ids of the labels.</span>
<span class="sd">    labels_name:</span>
<span class="sd">        List of the names of the diferents labels.</span>
<span class="sd">    labels_training:</span>
<span class="sd">        Array with all the ids of the labels used to train the MMSBM</span>
<span class="sd">    df:</span>
<span class="sd">        Dataframe with the links information, who connected to who and with which label are connected</span>
<span class="sd">    dict_codes: dict</span>
<span class="sd">        Dictionary with the integer ids of the labels. Keys are label names, and values are corresponding ids.</span>
<span class="sd">    nodes_a,nodes_b: nodes_layer</span>
<span class="sd">        nodes_layer objects of the nodes that are part from the bipartite network.</span>
<span class="sd">    links: 2D-array</span>
<span class="sd">        2D-array with the links of the nodes that are connected</span>
<span class="sd">    links_training: 2D-array</span>
<span class="sd">        2D-array with the links of the nodes that are connected used to train the MMSBM</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __len__()</span>
<span class="sd">        Returns the number of different labels.</span>
<span class="sd">    __str__()</span>
<span class="sd">        Returns the name of the labels column.</span>

<span class="sd">    init_EM(tol=0.001, training=None, seed=None)</span>
<span class="sd">        Initializes the EM algorithm to find the most plausible membership parameters of the MMSBM.</span>

<span class="sd">    init_EM_from_directory(training=None, dir=&quot;.&quot;)</span>
<span class="sd">        Initializes the EM algorithm using parameters saved in files in a specified directory.</span>

<span class="sd">    EM_step(N_steps=1)</span>
<span class="sd">        Performs N_steps steps of the EM algorithm.</span>

<span class="sd">    get_loglikelihood()</span>
<span class="sd">        Returns the loglikelihood of the current state of the MMSBM.</span>

<span class="sd">    get_links_probabilities(links=None)</span>
<span class="sd">        Returns the probability of each link in links.</span>

<span class="sd">    get_predicted_links(links=None)</span>
<span class="sd">        Returns the predicted label of each link in links.</span>

<span class="sd">    get_accuracy(predicted_labels = None, test_labels = None, Pij = None,links = None, estimator = &quot;max_probability&quot;)</span>
<span class="sd">        Returns the accuracy of the predicted labels.</span>

<span class="sd">    deep_copying()</span>
<span class="sd">        Returns a deep copy of the BiNet instance.</span>

<span class="sd">    converges()</span>
<span class="sd">        Returns True if the EM algorithm has converged, False otherwise.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class provides a structure to manage bipartite networks.</span>


<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="BiNet.__init__">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">links</span><span class="p">,</span> <span class="n">links_label</span><span class="p">,</span><span class="o">*</span><span class="p">,</span> <span class="n">nodes_a</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodes_b</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Ka</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nodes_a_name</span><span class="o">=</span><span class="s2">&quot;nodes_a&quot;</span><span class="p">,</span> <span class="n">Kb</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">nodes_b_name</span><span class="o">=</span><span class="s2">&quot;nodes_b&quot;</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dict_codes_a</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dict_codes_b</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Initialization of a BiNet class</span>

<span class="sd">         Parameters</span>
<span class="sd">         -----------</span>
<span class="sd">         links: str, pandas DataFrame</span>
<span class="sd">            DataFrame or directory containing the links between nodes_a and nodes_b and their labels.</span>

<span class="sd">         links_label: str</span>
<span class="sd">             Name of the column where the labels are stored in the links DataFrame.</span>

<span class="sd">         nodes_a: nodes_layer, str, DataFrame, None, default: None</span>
<span class="sd">             One of the nodes layer that forms the bipartite network</span>
<span class="sd">             - If nodes_layer: Existing instance of the nodes_layer class representing the first layer.</span>
<span class="sd">             - If str or pd.DataFrame: If str, a directory containing the file information about nodes_a.</span>
<span class="sd">             - If pd.DataFrame, DataFrame with nodes_a information.</span>
<span class="sd">             - If None: A simple nodes_layer will be created from the information in links.</span>

<span class="sd">         nodes_b: nodes_layer, str, DataFrame, None, default: None</span>
<span class="sd">             One of the nodes layer that forms the bipartite network</span>
<span class="sd">             - If nodes_layer: Existing instance of the nodes_layer class representing the first layer.</span>
<span class="sd">             - If str or pd.DataFrame: If str, a directory containing the file information about nodes_b.</span>
<span class="sd">             - If pd.DataFrame, DataFrame with nodes_b information.</span>
<span class="sd">             - If None: A simple nodes_layer will be created from the information in links.</span>

<span class="sd">         Ka: int, default: 1</span>
<span class="sd">            Number of membership groups for nodes_a layer</span>

<span class="sd">         Kb: int, default: 1</span>
<span class="sd">            Number of membership groups for nodes_b layer</span>

<span class="sd">         nodes_a_name: str, default: nodes_a</span>
<span class="sd">            Name of the column where the names of nodes_a are in the links DataFrame and nodes_a DataFrame</span>

<span class="sd">         nodes_b_name: str, default: nodes_b</span>
<span class="sd">            Name of the column where the names of nodes_b are in the links DataFrame and nodes_b DataFrame</span>

<span class="sd">         dict_codes: dict, None, default: None</span>
<span class="sd">            Dictionary where the keys are the names of the labels, and the values are the ids. If None, new ids will be provided.</span>

<span class="sd">         dict_codes_a: dict, None, default: None</span>
<span class="sd">            Dictionary where the keys are the names of the nodes from nodes_a and the values are the ids. If None, new ids will be provided.</span>

<span class="sd">         dict_codes_b: dict, None, default: None</span>
<span class="sd">            Dictionary where the keys are the names of the nodes from nodes_b and the values are the ids. If None, new ids will be provided.</span>

<span class="sd">         separator: str, default: \t</span>
<span class="sd">            Separator used to read links DataFrame file. Default is \t</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Checking type of links</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_separator</span> <span class="o">=</span> <span class="n">separator</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">links</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">separator</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;python&#39;</span><span class="p">)</span>


        <span class="c1"># creating first layer class</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="n">nodes_layer</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_a</span>
            <span class="n">nodes_a_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span>
            <span class="n">Ka</span> <span class="o">=</span> <span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="p">(</span><span class="n">Ka</span><span class="p">,</span> <span class="n">nodes_a_name</span><span class="p">,</span> <span class="n">nodes_a</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes_a</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="p">(</span><span class="n">Ka</span><span class="p">,</span> <span class="n">nodes_a_name</span><span class="p">,</span> <span class="n">nodes_a</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes_a</span><span class="p">)</span>
        <span class="k">elif</span>  <span class="n">nodes_a</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="o">.</span><span class="n">create_simple_layer</span><span class="p">(</span><span class="n">Ka</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">nodes_a_name</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span> <span class="n">nodes_a_name</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes_a</span><span class="p">)</span>

        <span class="c1"># creating second layer class</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="n">nodes_layer</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_b</span>
            <span class="n">nodes_b_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span>
            <span class="n">Kb</span> <span class="o">=</span> <span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="p">(</span><span class="n">Kb</span><span class="p">,</span> <span class="n">nodes_b_name</span><span class="p">,</span> <span class="n">nodes_b</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes_b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="p">(</span><span class="n">Kb</span><span class="p">,</span> <span class="n">nodes_b_name</span><span class="p">,</span> <span class="n">nodes_b</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes_b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">nodes_b</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="o">.</span><span class="n">create_simple_layer</span><span class="p">(</span><span class="n">Kb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">nodes_b_name</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span> <span class="n">nodes_b_name</span><span class="p">,</span> <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">dict_codes_b</span><span class="p">)</span>


        <span class="c1">## Coding labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span> <span class="o">=</span> <span class="n">links_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span> <span class="o">=</span> <span class="n">add_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">links_label</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dict_codes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#Checking type of labels</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int16&quot;</span><span class="p">):</span>
                <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="p">:</span>
                    <span class="n">new_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">new_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="p">:</span>
                    <span class="n">dict_codes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">dict_codes</span> <span class="o">=</span> <span class="n">new_dict</span>

            <span class="n">replacer</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">dict_codes</span><span class="p">:</span>
                <span class="n">replacer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span><span class="p">[</span><span class="n">att</span><span class="p">]]</span><span class="o">=</span> <span class="n">dict_codes</span><span class="p">[</span><span class="n">att</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span> <span class="o">=</span> <span class="n">dict_codes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">:</span><span class="n">replacer</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1">#Links</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">nodes_a_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="n">nodes_a_name</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="n">nodes_a_name</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">nodes_b_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="n">nodes_b_name</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="n">nodes_b_name</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">links_label</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[[</span><span class="n">nodes_a_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">,</span> <span class="n">nodes_b_name</span> <span class="o">+</span> <span class="s2">&quot;_id&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>




        <span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span></div>



    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dict_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dictionary with the integer ids of the labels. Keys are label names, and values are corresponding ids.</span>
<span class="sd">        The ids go from 0 to N_labels-1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span>

    <span class="nd">@dict_codes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dict_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes the ids (the integer assigned to each label) given the dict_codes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span> <span class="o">=</span> <span class="n">dc</span>
        <span class="k">return</span> <span class="n">dc</span>

<div class="viewcode-block" id="BiNet.load_BiNet_from_json">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.load_BiNet_from_json">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_BiNet_from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">json_file</span><span class="p">,</span> <span class="n">links</span><span class="p">,</span> <span class="n">links_label</span><span class="p">,</span><span class="o">*</span><span class="p">,</span> <span class="n">nodes_a</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodes_b</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodes_a_dir</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodes_b_dir</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a BiNet instance from a JSON file containing MMSBM parameters and link information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        json_file: str</span>
<span class="sd">            Path to the JSON files containing MMSBM parameters.</span>

<span class="sd">        links: str, pandas DataFrame</span>
<span class="sd">            DataFrame or directory containing the links between nodes_a and nodes_b and their labels.</span>

<span class="sd">        links_label: array-like</span>
<span class="sd">            Array-like object representing the labels corresponding to the links.</span>

<span class="sd">        nodes_a: nodes_layer, str, pd.DataFrame, None, default: None</span>
<span class="sd">            - If nodes_layer: Existing instance of the nodes_layer class representing the first layer.</span>
<span class="sd">            - If str or pd.DataFrame: If str, a name for the first layer. If pd.DataFrame, DataFrame with nodes and attributes.</span>
<span class="sd">            - If None: The first layer will be created later.</span>

<span class="sd">        nodes_b: nodes_layer, str, pd.DataFrame, None, default: None</span>
<span class="sd">            - If nodes_layer: Existing instance of the nodes_layer class representing the second layer.</span>
<span class="sd">            - If str or pd.DataFrame: If str, a name for the second layer. If pd.DataFrame, DataFrame with nodes and attributes.</span>
<span class="sd">            - If None: The second layer will be created later as a simple layer (no metadata)</span>

<span class="sd">        separator: str, default: &quot;\t&quot;</span>
<span class="sd">            Separator used in the provided JSON file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BN: BiNet</span>
<span class="sd">            Instance of the BiNet class loaded from the JSON file.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This class method allows loading a BiNet instance from a JSON file, along with links and labels. It constructs both</span>
<span class="sd">        nodes layers&#39; objects with metadata initialized based on the provided information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#open json</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>


        <span class="c1">#construct both nodes layers objects with metadata initialized</span>
        <span class="c1"># creating first layer class</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="n">nodes_layer</span><span class="p">):</span>
            <span class="n">na</span> <span class="o">=</span> <span class="n">nodes_a</span>
            <span class="n">nodes_a_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">na</span><span class="p">)</span>
            <span class="n">Ka</span> <span class="o">=</span> <span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nodes_a_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If nodes_a is a string or a DataFrame, nodes_a_dir must be provided (the same for nodes_b).&quot;</span><span class="p">)</span>
            <span class="n">na</span> <span class="o">=</span> <span class="n">load_nodes_layer_from_file</span><span class="p">(</span><span class="n">nodes_a</span><span class="p">,</span> <span class="n">nodes_a_dir</span><span class="p">)</span>
            <span class="n">Ka</span> <span class="o">=</span> <span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span>
        <span class="k">elif</span>  <span class="n">nodes_a</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#later it will be created</span>
            <span class="n">na</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># creating second layer class</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="n">nodes_layer</span><span class="p">):</span>
            <span class="n">nb</span> <span class="o">=</span> <span class="n">nodes_b</span>
            <span class="n">nodes_b_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
            <span class="n">Kb</span> <span class="o">=</span> <span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nodes_b_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;If nodes_b is a string or a DataFrame, nodes_b_dir must be provided (the same for nodes_a).&quot;</span><span class="p">)</span>
            <span class="n">nb</span> <span class="o">=</span> <span class="n">load_nodes_layer_from_file</span><span class="p">(</span><span class="n">nodes_b</span><span class="p">,</span> <span class="n">nodes_b_dir</span><span class="p">)</span>
            <span class="n">Kb</span> <span class="o">=</span> <span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span>
        <span class="k">elif</span>  <span class="n">nodes_b</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#later it will be created</span>
            <span class="n">nb</span> <span class="o">=</span> <span class="kc">None</span>



        <span class="c1">#creating BiNet</span>
        <span class="k">if</span> <span class="n">na</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nb</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">BN</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">links_label</span><span class="p">,</span>
                     <span class="n">nodes_a</span> <span class="o">=</span> <span class="n">na</span><span class="p">,</span> <span class="n">Ka</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Ka&quot;</span><span class="p">],</span> <span class="n">nodes_a_name</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nodes_a_name&quot;</span><span class="p">],</span>
                               <span class="n">dict_codes_a</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dict_codes_a&quot;</span><span class="p">],</span>
                     <span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">Kb</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Kb&quot;</span><span class="p">],</span> <span class="n">nodes_b_name</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nodes_b_name&quot;</span><span class="p">],</span>
                               <span class="n">dict_codes_b</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dict_codes_b&quot;</span><span class="p">],</span>
                     <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">,</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dict_codes&quot;</span><span class="p">])</span>



        <span class="k">elif</span> <span class="n">na</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">BN</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">links_label</span><span class="p">,</span>
                     <span class="n">nodes_a</span> <span class="o">=</span> <span class="n">na</span><span class="p">,</span> <span class="n">Ka</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Ka&quot;</span><span class="p">],</span> <span class="n">nodes_a_name</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nodes_a_name&quot;</span><span class="p">],</span>
                     <span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;separator&quot;</span><span class="p">],</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dict_codes&quot;</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">nb</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">BN</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">links_label</span><span class="p">,</span>
                     <span class="n">nodes_a</span> <span class="o">=</span> <span class="n">na</span><span class="p">,</span>
                     <span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">Kb</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;K&quot;</span><span class="p">],</span> <span class="n">nodes_b_name</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nodes_b_name&quot;</span><span class="p">],</span>
                     <span class="n">separator</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;separator&quot;</span><span class="p">],</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dict_codes&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">BN</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">links_label</span><span class="p">,</span>
                     <span class="n">nodes_a</span> <span class="o">=</span> <span class="n">na</span><span class="p">,</span>
                     <span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nb</span><span class="p">,</span>
                     <span class="n">separator</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;separator&quot;</span><span class="p">],</span><span class="n">dict_codes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dict_codes&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">BN</span></div>


<div class="viewcode-block" id="BiNet.__getitem__">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.__getitem__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the nodes_layer object of the specified type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes_type: str</span>
<span class="sd">            Name of the nodes_layer object to return.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes_layer</span>
<span class="sd">            The nodes_layer object of the specified type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nodes_type</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>
        <span class="k">elif</span> <span class="n">nodes_type</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes type </span><span class="si">{</span><span class="n">nodes_type</span><span class="si">}</span><span class="s2"> not found&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="BiNet.__setitem__">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.__setitem__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_type</span><span class="p">,</span> <span class="n">nodes_layer</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the nodes_layer object of the specified type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes_type: str</span>
<span class="sd">            Name of the nodes_layer object to set.</span>

<span class="sd">        nodes_layer: nodes_layer</span>
<span class="sd">            The nodes_layer object to set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nodes_type</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_layer</span>
        <span class="k">elif</span> <span class="n">nodes_type</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_layer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nodes type not found&quot;</span><span class="p">)</span></div>



    <span class="c1">#EM algorithm</span>
<div class="viewcode-block" id="BiNet.init_EM">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.init_EM">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_EM</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">training</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize the EM algorithm to get the most plausible membership parameters of the MMSBM</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        tol : float, default: 0.001</span>
<span class="sd">            Tolerance of the algorithm when finding the parameters.</span>

<span class="sd">        seed : int, None, default: None</span>
<span class="sd">            Seed to generate the matrices. Is initialized using the np.random.RandomState(seed) method.</span>

<span class="sd">        training : DataFrame, list, default: None</span>
<span class="sd">            - If DataFrame: DataFrame with the links used to train the MMSBM.</span>
<span class="sd">            - If list or ndarray: List or array containing the indexes of the links list used for training.</span>
<span class="sd">            - If None: Uses self.links and self.labels_array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method initializes the EM algorithm by setting up probability matrices (BiNet.pkl), memberships (BiNet.nodes_a.theta and BiNet.nodes_b.theta), and managing</span>
<span class="sd">        links to train. The tolerance, seed, and training data can be specified to customize the initialization process.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Probability matrices</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>

        <span class="c1">#BiNet matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pkl</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span><span class="p">)</span>

        <span class="c1">#memberships (thetas)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>

        <span class="c1"># Links to train management</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span> <span class="o">=</span> <span class="n">training</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span> <span class="o">=</span> <span class="n">training</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">training</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span><span class="p">[</span><span class="n">training</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">training</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span>

        <span class="c1">#masks list to know wich links have label r (that is the index of the list)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks_label_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span><span class="o">==</span><span class="n">r</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">masks_label_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1">#observed nodes in each layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">#non_observed nodes in each layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_observed_nodes_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_a</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_observed_nodes_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_b</span><span class="p">])</span>




        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span><span class="p">)</span>



        <span class="c1">#Metadata</span>
        <span class="c1">## qka and omegas</span>
        <span class="k">for</span> <span class="n">meta_name</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">qka</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays_exclusive</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">meta_name</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">qka</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays_exclusive</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>

        <span class="c1">## q_k_tau, zetes and omegas omega_comp_arrays(omega,p_kl,theta,eta,K,L,links_array,links_ratings):</span>
        <span class="k">for</span> <span class="n">meta_name</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">zeta</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span> <span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

            <span class="c1">#neighbours and denominators from meta</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">)):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">neighbours_meta</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>



        <span class="k">for</span> <span class="n">meta_name</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">zeta</span> <span class="o">=</span> <span class="n">init_P_matrix</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span> <span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

            <span class="c1">#neighbours and denominators from meta</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">)):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">neighbours_meta</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>


        <span class="c1">#creating arrays with the denominator (that are constants) of each node in both layers and em layers</span>

        <span class="c1">##nodes a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_a</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#list of list of neighbours</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)):</span>
            <span class="c1">#neighbours in BiNet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">#neighbours in meta exclusives</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span>

        <span class="c1">#neighbours in meta inclusives</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">,:])</span>


            <span class="c1">#for i, meta in enumerate(self.nodes_a.meta_exclusives):</span>
                <span class="c1">#self.node_a.denominators[node] += meta.lambda_vals*</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1">##nodes b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_b</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#list of list of neighbours</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)):</span>
            <span class="c1">#neighbours in BiNet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">#neighbours in meta exclusives</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span>

        <span class="c1">#neighbours in meta inclusives</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">,:])</span>

            <span class="c1">#neighbours in meta inclusives</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span></div>

            <span class="c1"># for meta in self.nodes_b.meta_exclusives:</span>

<div class="viewcode-block" id="BiNet.save_BiNet">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.save_BiNet">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_BiNet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span><span class="n">layers</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        It saves the BiNet data into a JSON file in dir. If layers==True,</span>
<span class="sd">        it saves the nodes_layer objects in JSONs files in the same directory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        dir: str</span>
<span class="sd">            Directory where the JSON with the BiNet information will be saved</span>
<span class="sd">        layers: bool, default: True</span>
<span class="sd">            If True, it saves the nodes_layer objects in JSONs files in the same directory.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">functions</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">save_BiNet_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">layers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">save_nodes_layer</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">save_nodes_layer</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span></div>


<div class="viewcode-block" id="BiNet.load_BiNet_from_file">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.load_BiNet_from_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_BiNet_from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">df_links</span><span class="p">,</span><span class="n">json_dir</span><span class="p">,</span> <span class="n">layers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">*</span><span class="p">,</span> <span class="n">nodes_a</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nodes_b</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        It loads the BiNet data from a JSON file in dir</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        dir: str</span>
<span class="sd">            Directory where the JSON with the BiNet information is saved</span>
<span class="sd">        layers: bool, default: True</span>
<span class="sd">            If True, it loads the nodes_layer objects from the JSON file in the same directory.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">json_dir</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">BN</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">links</span><span class="o">=</span><span class="n">df_links</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">BN</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="o">.</span><span class="n">load_nodes_layer_from_file</span><span class="p">(</span><span class="n">json_dir</span><span class="p">)</span>
            <span class="n">BN</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_layer</span><span class="o">.</span><span class="n">load_nodes_layer_from_file</span><span class="p">(</span><span class="n">json_dir</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nodes_a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">BN</span><span class="o">.</span><span class="n">nodes_a</span> <span class="o">=</span> <span class="n">nodes_a</span>
            <span class="k">if</span> <span class="n">nodes_b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">BN</span><span class="o">.</span><span class="n">nodes_b</span> <span class="o">=</span> <span class="n">nodes_b</span>
            


        
        <span class="k">return</span> <span class="n">BN</span></div>

    
    
<div class="viewcode-block" id="BiNet.init_EM_from_directory">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.init_EM_from_directory">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_EM_from_directory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize the Expectation Maximization (EM) algorithm to obtain the most plausible membership parameters of the</span>
<span class="sd">        Mixed-Membership Stochastic Block Model (MMSBM) using parameters saved in files located in a specified directory.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            dir: str, default: &quot;.&quot;</span>
<span class="sd">                Directory where the files with the MMSBM parameters will be loaded.</span>

<span class="sd">            training: pd.DataFrame, list, ndarray, default: None</span>
<span class="sd">                - If pd.DataFrame: DataFrame containing the training links and labels.</span>
<span class="sd">                - If list or ndarray: List or array containing the positions of the links list from self.df attribute.</span>
<span class="sd">                - If None: Uses self.links_training and self.labels_training.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>


        <span class="n">load_EM_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="nb">dir</span><span class="p">)</span>

        <span class="c1"># Links to train management</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">training</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">training</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">training</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)]]</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">training</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">training</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">training</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)]]</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span> <span class="o">=</span> <span class="n">training</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span> <span class="o">=</span> <span class="n">training</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">training</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span><span class="p">[</span><span class="n">training</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">training</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span>

        <span class="c1">#Omegas and denominators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">na</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="n">na</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">na</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span><span class="p">)</span>


        <span class="c1">#masks list to know wich links have label r (that is the index of the list)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks_label_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span><span class="o">==</span><span class="n">r</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">masks_label_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1">#Metadata</span>
        <span class="c1">## qka and omegas</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">na</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays_exclusive</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="n">na</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">na</span><span class="p">),</span><span class="n">na</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays_exclusive</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">),</span><span class="n">nb</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">na</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">na</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="n">na</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="n">na</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="c1">#neighbours and denominators from meta</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">)):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">neighbours_meta</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>



        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

            <span class="c1">#neighbours and denominators from meta</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">)):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">neighbours_meta</span><span class="p">)</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>


        <span class="c1">#creating arrays with the denominator (that are constants) of each node in both layers and em layers</span>

        <span class="c1">##nodes a</span>
        <span class="n">na</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">na</span><span class="p">))</span>

        <span class="c1">#observed and nonobserved nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_observed_nodes_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_a</span><span class="p">])</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_a</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#list of list of neighbours</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_a</span><span class="p">:</span>
            <span class="c1">#neighbours in BiNet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">na</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">#neighbours in meta exclusives</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">na</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">na</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span>

        <span class="c1">#neighbours in meta inclusives</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">na</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">na</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">na</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">,:])</span>


        <span class="n">na</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">na</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>



        <span class="c1">##nodes b</span>
        <span class="c1">#observed and nonobserved nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_observed_nodes_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_b</span><span class="p">])</span>


        <span class="n">nb</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_b</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#list of list of neighbours</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observed_nodes_b</span><span class="p">:</span>
            <span class="c1">#neighbours in BiNet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">][:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">nb</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbours_nodes_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">#neighbours in meta exclusives</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">nb</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span>

        <span class="c1">#neighbours in meta inclusives</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nb</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">nb</span><span class="o">.</span><span class="n">denominators</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meta</span><span class="o">.</span><span class="n">lambda_val</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">node</span><span class="p">,:])</span>

            <span class="c1">#neighbours in meta inclusives</span>

        <span class="n">nb</span><span class="o">.</span><span class="n">denominators</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">denominators</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span></div>



<div class="viewcode-block" id="BiNet.EM_step">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.EM_step">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">EM_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N_steps</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the N_steps number of steps to update the model parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        N_steps: int, default: 1</span>
<span class="sd">            Number of EM steps to be performed. Default is 1.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method updates the model parameters using the Expectation Maximization (EM) estimation.</span>
<span class="sd">        The Maximum a Posteriori algorithm is employed for iterative updates.</span>

<span class="sd">        During each step, the following updates are performed:</span>
<span class="sd">        - Update of nodes_a parameters (BiNet.nodes_a.theta).</span>
<span class="sd">        - Update of exclusive_meta and inclusive_meta for nodes_a (BiNet.nodes_a.meta.theta).</span>
<span class="sd">        - Update of nodes_b parameters ((BiNet.nodes_b.theta)).</span>
<span class="sd">        - Update of exclusive_meta and inclusive_meta for nodes_b (BiNet.nodes_b.meta.theta)..</span>
<span class="sd">        - Update of link probabilities (BiNet.pkl) and omega (BiNet.omega).</span>

<span class="sd">        After each step, a deep copy of the current model parameters is stored for convergence tracking.</span>

<span class="sd">        It is recommended to perform multiple EM steps to refine the model parameters.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#getting copies from the actual parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deep_copying</span><span class="p">()</span>

        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>

        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_steps</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">layer</span><span class="p">,</span><span class="n">layer_str</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">na</span><span class="p">,</span><span class="s2">&quot;a&quot;</span><span class="p">),(</span><span class="n">nb</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="p">)]:</span>
                <span class="c1">#layer update</span>
                <span class="c1"># print(f&quot;layer {layer} ({layer_str})&quot;)</span>
                <span class="c1"># print(f&quot;\t\t theta&quot;)</span>

                <span class="n">layer</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">theta_comp_arrays_multilayer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">layer_str</span><span class="p">)</span>

                <span class="c1">##nodes_a exclusive_meta update</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
<span class="c1">#                     print(f&quot;\t\tmeta {meta}&quot;)</span>
                    <span class="n">meta</span><span class="o">.</span><span class="n">qka</span> <span class="o">=</span> <span class="n">q_ka_comp_arrays</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">masks_att_list</span><span class="p">)</span>
                    <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays_exclusive</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="n">layer</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">),</span><span class="n">layer</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>


                <span class="c1">##nodes_a inclusive_meta update</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="c1">#print(f&quot;\t\tmeta: {meta}&quot;)</span>
                    <span class="n">meta</span><span class="o">.</span><span class="n">zeta</span> <span class="o">=</span> <span class="n">theta_comp_array</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">N_att</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">denominators</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">masks_att_list</span><span class="p">)</span>
                    <span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span> <span class="o">=</span> <span class="n">p_kl_comp_arrays</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">masks_label_list</span><span class="p">)</span>
                    <span class="n">meta</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layer</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">),</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="n">layer</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="n">layer</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">Tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pkl</span> <span class="o">=</span> <span class="n">p_kl_comp_arrays</span><span class="p">(</span><span class="n">na</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks_label_list</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega_comp_arrays</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">K</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span><span class="p">)</span></div>



<div class="viewcode-block" id="BiNet.get_log_likelihoods">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.get_log_likelihoods">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_log_likelihoods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It computes the log_likelihoods from every bipartite network of the multipartite network</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>

        <span class="c1">#log-like from the labels network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">log_like_comp</span><span class="p">(</span><span class="n">na</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">nb</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span><span class="p">)</span>

        <span class="c1">#log-like from the metadata networks</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="p">[</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">]:</span>
            <span class="c1">#log-like inclusives meta</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">log_like_comp</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="c1">#log-like exclusives meta</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">log_like_comp_exclusive</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">links</span><span class="p">)</span></div>


<div class="viewcode-block" id="BiNet.get_links_probabilities">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.get_links_probabilities">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_links_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">links</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the label probabilities for links in the trained BiNet.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        links : ndarray or DataFrame, optional, default: None</span>
<span class="sd">            Array or DataFrame with links for which probabilities are computed.</span>
<span class="sd">            - If 2D array, the first column should contain node IDs from nodes_a layer, and the second column from nodes_b layer.</span>
<span class="sd">            - If 1D array, it should contain positions of links in self.df attribute.</span>
<span class="sd">            - If DataFrame, it should have at least two columns with names of the nodes layers.</span>
<span class="sd">            - If None, self.links_training will be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Pij_r : ndarray, shape (len(links), self.N_labels)</span>
<span class="sd">            Pij_r[l, r] is the probability that link l has label r.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">links</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Pij</span> <span class="o">=</span> <span class="n">total_p_comp_test</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">links_training</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">links</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">N</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">links</span> <span class="o">=</span> <span class="n">links</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
            <span class="k">elif</span> <span class="n">N</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">links</span> <span class="o">=</span> <span class="n">links</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span><span class="o">.</span><span class="n">values</span>
            <span class="k">elif</span> <span class="n">N</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">links</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">links</span> <span class="o">=</span> <span class="n">links</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span><span class="o">.</span><span class="n">values</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">links</span> <span class="o">=</span> <span class="n">links</span><span class="p">[[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">})</span><span class="o">.</span><span class="n">values</span>

            <span class="n">Pij</span> <span class="o">=</span> <span class="n">total_p_comp_test</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="n">links</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Pij</span> <span class="o">=</span> <span class="n">total_p_comp_test</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">links</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">Pij</span> <span class="o">=</span> <span class="n">total_p_comp_test</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="n">links</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Pij</span></div>



<div class="viewcode-block" id="BiNet.get_predicted_labels">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.get_predicted_labels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_predicted_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">links</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Pij</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="n">estimator</span> <span class="o">=</span> <span class="s2">&quot;max_probability&quot;</span><span class="p">,</span> <span class="n">to_return</span> <span class="o">=</span> <span class="s2">&quot;df&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Computes the predicted labels of the model based on the MMSBM parameters, using different estimators. They can be measured by different estimators:</span>
<span class="sd">            - max_probability: The predicted label will be the most plausible label</span>
<span class="sd">            - mean: The predicted label will be the mean</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        links: ndarray of 1 or 2 dimensions, pandas DataFrame, default: None</span>
<span class="sd">            Array with links for which label probabilities are computed.</span>
<span class="sd">            -If a 2d-array, the first column must contain the ids from nodes_a layer and the second</span>
<span class="sd">             column must contain the ids from nodes_b layers.</span>
<span class="sd">            -If a 1d-array, it must contain the positions of the links list from self.df attribute</span>
<span class="sd">            -If a pandas DataFrame, it must contain at least two columns with the name of the nodes&#39; layers</span>
<span class="sd">             and a column with the same name as the labels column from BiNet.df.</span>
<span class="sd">            -If None, self.links_training will be used.</span>

<span class="sd">        Pij: ndarray, default: None</span>
<span class="sd">            Array with the probabilities of the links to have each label. If None, it will compute the probabilities using self.get_links_probabilities(links).</span>

<span class="sd">        estimator: {&quot;max_probability&quot;,&quot;average&quot;}, default: max_probability</span>
<span class="sd">            Estimator used to get predicted labels:</span>
<span class="sd">            - &quot;max_probability&quot;: Selects the most plausible label.</span>
<span class="sd">            - &quot;average&quot;: Selects the average label (sum [Pij(l) * l]).</span>

<span class="sd">        to_return: {&quot;df&quot;,&quot;ids&quot;, &quot;both&quot;}, default: df</span>
<span class="sd">            Option to choose how the predicted labels will be returned.</span>
<span class="sd">             -&quot;df&quot;: Returns a DataFrame with columns for nodes from both layers and an additional column called &quot;Predicted + self.label_name&quot;.</span>
<span class="sd">             -&quot;ids&quot;: Returns a ndarray of ints with the ids of the predicted labels.</span>
<span class="sd">             -&quot;both&quot;: Returns both the DataFrame and the ndarray with the ids in this order.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        labels_id: ndarray</span>
<span class="sd">            Predicted labels id.</span>

<span class="sd">        labels_df: pandas DataFrame</span>
<span class="sd">            DataFrame whose columns are nodes_a, nodes_b and the predicted labels</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If Pij is provided, it will use the given probabilities; otherwise, it will compute probabilities using self.get_links_probabilities(links).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Pij</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">estimator</span><span class="o">==</span><span class="s2">&quot;max_probability&quot;</span><span class="p">:</span>
                <span class="n">labels_id</span> <span class="o">=</span>  <span class="n">Pij</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">estimator</span><span class="o">==</span><span class="s2">&quot;mean&quot;</span><span class="p">:</span>
                <span class="n">labels_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">Pij</span><span class="nd">@np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Pij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_links_probabilities</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">estimator</span><span class="o">==</span><span class="s2">&quot;max_probability&quot;</span><span class="p">:</span>
                <span class="n">labels_id</span> <span class="o">=</span> <span class="n">Pij</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">estimator</span><span class="o">==</span><span class="s2">&quot;mean&quot;</span><span class="p">:</span>
                <span class="n">labels_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">Pij</span><span class="nd">@np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">N_labels</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])[:,</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;df&quot;</span> <span class="ow">or</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">links</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">to_link</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links_training</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">decoder</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span><span class="p">}</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">decoder</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">labels_id</span><span class="p">]</span>
                <span class="n">result_df</span> <span class="o">=</span> <span class="n">links</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">result_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;Predicted &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span>

                <span class="k">if</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;df&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result_df</span>
                <span class="k">elif</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result_df</span><span class="p">,</span> <span class="n">labels_id</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">to_link</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">links</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">to_link</span> <span class="o">=</span> <span class="n">links</span>


            <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>
            <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>

            <span class="n">decoder</span> <span class="o">=</span> <span class="p">{</span><span class="n">na</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">na</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">}</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">decoder</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">to_link</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span>

            <span class="n">decoder</span> <span class="o">=</span> <span class="p">{</span><span class="n">nb</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nb</span><span class="o">.</span><span class="n">dict_codes</span><span class="p">}</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">decoder</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">to_link</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">decoder</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span><span class="p">}</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">decoder</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">labels_id</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;df&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">na</span><span class="p">):</span><span class="n">A</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span><span class="n">B</span><span class="p">,</span><span class="s2">&quot;Predicted &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">:</span><span class="n">labels</span><span class="p">})</span>
            <span class="k">elif</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">na</span><span class="p">):</span><span class="n">A</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span><span class="n">B</span><span class="p">,</span><span class="s2">&quot;Predicted &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">:</span><span class="n">labels</span><span class="p">}),</span> <span class="n">labels_id</span>

        <span class="k">elif</span> <span class="n">to_return</span> <span class="o">==</span> <span class="s2">&quot;ids&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">labels_id</span></div>


<div class="viewcode-block" id="BiNet.get_accuracy">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.get_accuracy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_accuracy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicted_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">test_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Pij</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">links</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">estimator</span> <span class="o">=</span> <span class="s2">&quot;max_probability&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the ratio of correctly predicted labels of the model given the MMSBM parameters. They can be measured by different estimators:</span>
<span class="sd">            -max_probability: The predicted label will be the most plausible label</span>
<span class="sd">            -mean: The predicted label will be the mean</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predicted_labels: array-like, default:None.</span>
<span class="sd">            Array-like with the predicted labels ids given by the MMSBM. If None, predictions will be generated using</span>
<span class="sd">        the specified links and estimator.</span>

<span class="sd">        test_labels: array-like, default:None.</span>
<span class="sd">            List or array with the observed labels. If None, labels from self.labels_array are taken given pos_test_labels</span>

<span class="sd">        links: ndarray of 1 or 2 dimensions, pandas DataFrame, default: None</span>
<span class="sd">            Array with links for which label probabilities are computed.</span>
<span class="sd">            -If a 2d-array, the first column must contain the ids from nodes_a layer and the second</span>
<span class="sd">             column must contain the ids from nodes_b layers.</span>
<span class="sd">            -If a 1d-array, it must contain the positions of the links list from self.df attribute</span>
<span class="sd">            -If a pandas DataFrame, it must contain at least two columns with the name of the nodes&#39; layers</span>
<span class="sd">             and a column with the same name as the labels column from BiNet.df.</span>
<span class="sd">            -If None, self.links_training will be used.</span>


<span class="sd">        estimator: {&quot;max_probability&quot;,&quot;mean&quot;}, default: max_probability</span>
<span class="sd">            Estimator used to get the predicted labels:</span>
<span class="sd">            -max_probability: Selects the most plausible label</span>
<span class="sd">            -mean: Selects the mean label (sum [Pij(l)*l])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        accuracy: float</span>
<span class="sd">            Ratio of correctly predicted labels to the total number of predicted labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#If predicted labels are not provided, it will compute them</span>
        <span class="k">if</span> <span class="n">predicted_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">predicted_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_predicted_labels</span><span class="p">(</span><span class="n">links</span><span class="o">=</span><span class="n">links</span><span class="p">,</span> <span class="n">Pij</span><span class="o">=</span><span class="n">Pij</span><span class="p">,</span> <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">,</span> <span class="n">to_return</span><span class="o">=</span><span class="s2">&quot;ids&quot;</span><span class="p">)</span>

        <span class="c1">#If test labels are not provided, we get them from links</span>
        <span class="k">if</span> <span class="n">test_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">links</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">test_labels</span> <span class="o">=</span> <span class="n">links</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="k">elif</span> <span class="n">links</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">isin</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">)])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">test_labels</span> <span class="o">=</span> <span class="n">links</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">labels_name</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_dict_codes</span><span class="p">})</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">links</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">test_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_array</span><span class="p">[</span><span class="n">links</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Missing test label information to compare:</span>
<span class="s2">                                     -Array in test_labels with labels ids.</span>
<span class="s2">                                     -Pandas DataFrame with links and their labels in links parameter.</span>
<span class="s2">                                     -Links position of the BiNet.links_array.&quot;&quot;&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">links</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">test_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_training</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">predicted_labels</span><span class="o">==</span><span class="n">test_labels</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_labels</span><span class="p">)</span></div>


<div class="viewcode-block" id="BiNet.deep_copying">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.deep_copying">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">deep_copying</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a deep copy of all parameters in the EM algorithm.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method creates deep copies of various parameters to store their current states for future reference and convergence checking.</span>

<span class="sd">        - Link Parameters:</span>
<span class="sd">            - pkl_old: Deep copy of the link probabilities (self.pkl).</span>
<span class="sd">            - omega_old: Deep copy of omega (self.omega).</span>

<span class="sd">        - Metadata parameters (for each layer):</span>
<span class="sd">            - theta_old: Deep copy of the layer&#39;s theta parameters (self.theta).</span>
<span class="sd">            - Inclusive metadata:</span>
<span class="sd">                - zeta_old: Deep copy of zeta (meta.zeta).</span>
<span class="sd">                - q_k_tau_old: Deep copy of q_k_tau (meta.q_k_tau).</span>
<span class="sd">                - omega_old: Deep copy of omega (meta.omega).</span>
<span class="sd">            - Exclusive metadata:</span>
<span class="sd">                - qka_old: Deep copy of qka (meta.qka).</span>
<span class="sd">                - omega_old: Deep copy of omega (meta.omega).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">pkl_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


        <span class="c1">##Metas copies</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="p">[</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">]:</span>
            <span class="n">layer</span><span class="o">.</span><span class="n">theta_old</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1">##inclusive_meta copies</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">zeta_old</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau_old</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">omega_old</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1">##exclusive_meta copies</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">qka_old</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">meta</span><span class="o">.</span><span class="n">omega_old</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="BiNet.converges">
<a class="viewcode-back" href="../modules.html#__init__.BiNet.converges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">converges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the parameters have converged during the EM procedure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the parameters have converged, False otherwise.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Convergence is determined based on the tolerance (self.tol) set for the model.</span>

<span class="sd">        - Meta Convergence:</span>
<span class="sd">            - Checks convergence for each layer&#39;s theta and metadata parameters.</span>
<span class="sd">            - Metadata parameters include zeta, q_k_tau, and omega for both inclusive and exclusive metadata.</span>

<span class="sd">        - Links Convergence:</span>
<span class="sd">            - Checks convergence for pkl (link probabilities) and omega parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_a</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_b</span>

        <span class="n">tol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span>


        <span class="c1">##Metas convergence</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="p">[</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">theta_old</span><span class="p">,</span><span class="n">layer</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="c1">##inclusive_meta convergence</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_inclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta_old</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau_old</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">q_k_tau</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">omega_old</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>

            <span class="c1">##exclusive_meta convergence</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">meta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">meta_exclusives</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">qka_old</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">qka</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">omega_old</span><span class="p">,</span><span class="n">meta</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>

        <span class="c1">#links convergence</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl_old</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pkl</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span><span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">finished</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega_old</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span><span class="n">tol</span><span class="p">):</span><span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Oscar Fajardo Fontiveros.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>